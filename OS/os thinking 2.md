## os thinking 2

**姓名：** 李婧如		**学号：** 1700012993

### 虚拟页式存储

#### 解释 LRU 算法硬件实现

- 每次访问，将访问到的行置1，列置0，最终行值最小的页面为最近最少使用的页面。

- 一个页面被访问时，对应行设为1，则该行为所有行中的最大之一。而下一步将对应的列置0，保证了这一行是唯一的最大值。这是因为对其他行来说，被置零的那一位之外的位一定不全为1。
- 越长时间没有被访问的页面，对应的行元素里面被置0的列越多，即行值越小。

#### 老化算法与 LRU 的比较

- 空间方面，老化算法比 LRU 更节省空间。因为移位寄存器个数和页面数一样，但是每个寄存器的长度没有页面数j多。矩阵法需要 `n*n` 维的空间，而老化算法只需要 `n*L` 维，这里 L 寄存器的长度。
- 时间方面，老化算法更节省时间。LRU 矩阵算法中，每次访问都会更新矩阵，而老化算法不需要每次都更新。只需要在规定长度的时间内更新一次即可。
- 老化算法不是绝对的 LRU，它优先考虑”最近“，而不是”最少”。发生的时间越久远，权值越小。

#### 页尺寸对缺页次数的影响

若增大页尺寸，缺页次数会先增加后减少。原因是增大尺寸时，能放进内存的页数目变少，但是地址空间很大，CPU 需要频繁更换页面，因此缺页次数增加。而当页面尺寸大到能够覆盖整个进程的地址空间时，缺页率将降低。

### windows 虚拟页式存储

#### 总结 Windows 自映射机制的实现原理

- 虚拟地址空间大小为 4GB，一个页面大小 4KB，故整个虚拟地址空间有 4GB/4KB = 1M 个页面。而每个页需要用页表项记录虚拟地址到物理地址的转换关系，且每个页表项需要 4B，故需要 4MB 空间存储页表项。4MB/4KB = 1024，即需要 1024  页存储页表。用页目录项存储每个页表页的地址，1024 个页目录项占 4B*1024 = 4KB，刚好可以用一页存下。
- 为了通过同一个机制找到页目录项（PDE）和页表项（PTE），建立自映射机制，即 `PD[0xc0300000>>22]` 指向了 PD 自身的首地址，其他位置则存放 PTE。思想是将页目录本身和页表看作同等地位的页。由于 PDE 占 4B，故 第 `va<<22` 个 PDE 的地址是 `(((va)>>22)<<2)+PDE_BASE` 。
- 对于任何一个 32 位地址，去掉最低的两位后把剩余的 30 位分成 3 份，最高的 10 位以 CR3 中的页目录地址为基地址，中间 10 位以高 10 位取出的地址作为基地址，低 10 位以中间 10 位作为基地址。10 位数为索引。 如此操作，取出的可能是 PDE 的物理地址（因为指向了自身），也可能是具体某个物理页的地址。

#### 总结 Windows 的物理内存管理

- PFN database：页框号数据库，描述物理内存中每个页面的状态。数据结构为数组，每个元素表示一页。PFN 数据库与页表的关系是页表中有效的 PTE 将指向 PFN 数据库中的一项，对应的 PFN 数据库也往回指向使用它的页表项。PFN 数组中相同状态的页框通过页表链接，链表表头描述了该链具体属于哪个状态，例如 Zeroed，Free，Modified，Standby 链表。

- PFN 数据库记录的页面状态有：

  - Zeroed：页面空闲，且用0初始化。
  - Free：页面空闲。
  - Standby：后备页面，曾经在某个工作集中，且内容没有被进程改变，PTE 仍是该页框号但设置为 invalid + transition。再次访问该页面只要重新设定 PTE 的标志，即 standby $\to$ active。
  - Modified：该页框曾在某个进程的工作集中，且被进程使用时有所改变。PTE 仍是该页框号但设置为 invalid + transition。再次访问该页面只要重新设定 PTE 的标志，即 modified $\to$ active。该页框被填充新的内容之前需要将原来内容写入磁盘。
  - Active/Valid：该页框在某个进程的工作集中。
  - Transition：过渡阶段，正在从文件中读页框或正在向文件中写页框。

- 状态转换：

  - 请求0页的 page fault 发生时，内存管理进程先从 zero list 中找，没有则从 free list 中找并刷零，free list 也为空则从 standby list 中找并刷零。free list 中的页面通过空闲进程（0号进程，刷零）刷零后进入 zero list。
  - 如果内存管理进程需要一个不必刷零的进程时，先找 free list，为空则找 standby list。使用 standby list 中的页面时需要先将指向该页面的 PTE 中的指针去掉。
  - 当一个进程从工作集中放弃某个页面，如果页面未被修改则进入 standby list 否则进入 modified list。当进程退出时所有私有页面进入 free list。当对于某共享页面的最后一个引用消失时也进入 free list。
  - 当 modified list 过大，或者 zero 和 standby list 的大小低于某个阈值时，modified page writer 进程将 modified list 中的页面写回磁盘，并将其移到 standby list 当中。

  ![image-20191202134422638](C:\Users\17000\AppData\Roaming\Typora\typora-user-images\image-20191202134422638.png)

- PFN 的结构：24 字节，对每种状态的页面存储的内容不同。如图所示：

![image-20191202143920762](C:\Users\17000\AppData\Roaming\Typora\typora-user-images\image-20191202143920762.png)