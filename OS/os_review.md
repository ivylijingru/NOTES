## 文件原理

### 文件系统的实现

- 文件系统的布局
- 文件的实现（数据在磁盘上的存放方式）
  - 连续空间存放方式
  - 非连续空间存放方式
  - FAT文件系统
  - 索引文件组织（UNIX INODE）
  - 多级索引组织
  - 非对称多级索引
  - 文件缓存
- 目录实现：地址独立
  - 文件属性的存放
  - 长文件名的存放
  - 文件共享
  - 硬连接，软连接
  - 切断链接
  - 链接带来的问题
  - 文件系统挂载
  - 卸载
- 闲置空间管理
  - 磁盘分配块
  - 磁盘配额

### 文件系统性能

- 文件授权管理
- 主动控制：访问控制表，文件角度
- 能力表：用户角度
- 文件系统性能
  - 文件系统可靠性（持久性，一致性）
  - 文件系统持久性（做备份）
  - 文件系统一致性（指元数据的不一致，包括空闲块管理区和 FCB 中的信息）
- 文件系统效率性能
  - 文件缓存
  - 虚拟内存和文件缓存（不同：VM 将内存扩展到磁盘上）
  - 提前读取
  - 减少磁臂移动（INODE 不集中存放，和数据块放在一起；**文件读写操作进行适当排序）**

## 内存

### 基本内存管理

- 内存管理的目标（地址独立，地址保护）
- 虚拟内存的概念
- 多道编程的内存管理（运行时计算物理地址、进行地址翻译：动态地址翻译）
  - 固定分区
  - 地址翻译的方法（起始地址+虚拟地址=物理地址）
  - 非固定分区（一个程序可以加载到任何地方）
  - 交换（空间不够的换到磁盘上，把小一点的换上来，有地方再换回去）
  - 重叠（将程序分成块，内存装不下整个程序则一块一块换上内存）
- 闲置空间管理
  - 位图法，用 0/1 表示内存单元是否闲置
  - 链表法，记录空闲块首地址和长度

### 页式内存管理

- 基址极限管理模式的问题

  - 空间浪费问题（外部碎片浪费空间）
  - 程序受限问题（单一程序不能超过物理内存，程序必须全部加载才能运行）

- 分页内存管理（虚拟地址为页面号+页面偏移）

  - 地址翻译

  - 页表（地址翻译、进行页面的状态判断）

    | 禁止缓存           | 访问位       | 修改位               | 保护位           | 有效位         | 物理页面号 |
    | ------------------ | ------------ | -------------------- | ---------------- | -------------- | ---------- |
    | 该页面是否允许缓存 | 是否被访问过 | 在内存中是否被修改过 | 读、写、执行权限 | 该页是否在内存 | 如果在内存 |

  - 页面翻译过程

- 分页系统的优缺点

  - 多级页表（解决页表全部放在内存上太大的缺点，将一部分有用的页表放在内存，其他页表放在磁盘；缺点是降低了访问内存的速度）

  - 反转页表（不增加级数情况下降低页表空间，存放物理页面到虚拟页面的映射，散列法将虚拟页号散列到物理页号）

    | 物理页号 | 进程PID                                               | 虚拟页号 | next                           |
    | -------- | ----------------------------------------------------- | -------- | ------------------------------ |
    |          | 通过 PID 和虚拟页号 hash 到物理页号，然后从冲突链中找 |          | 指向有相同 hash 值的下一个表项 |

  - 翻译速度（TLB，存放翻译结果的缓存，同时比较）

- 缺页中断处理（缺页中断关键步骤：检查地址合法性，选择一个物理页面存放新调入的页面，如果该物理页面在内存中被修改，则先写盘，调入新的页面后更新页表）
- 锁住页面（页表相应位做标记，该页较重要，选择换出去的页面时不选择它）
- 页面尺寸

### 页面更换算法

- 随机更换算法
- FIFO（只考虑进入内存的时间，不考虑页面被访问的频率）
- 第二次机会（FIFO 更换页面时，检查访问位判断最近是否被访问过，若为 0 则换出；为 1 则给第二次机会，访问位清零，从队尾移到队首）
- 时钟算法（与第二次机会算法数据结构上不一样，用整数索引）
- 最优更换（无法实现，选择一个随后最长时间内不会被访问的页面更换）
- NRU 算法（考虑最近一段时间内是否被使用，很久以前被访问的则忽略，这通过定期清零访问位实现；但分类笼统，无法分辨哪个页面访问时间最近）
- LRU 算法（不仅考虑是否使用过，还考虑最近使用的频率；用矩阵、移位寄存器实现不精确的 LRU 算法）
- 工作集算法（记住页面最后一次被访问的时间。每次扫描所有页面，若访问位=1则将最后使用时间设为当前时间，若=0且在工作集内 age <= T 则记住最早的时间，否则替换此页面）
- 工作集时钟算法
- 页面替换策略（全局策略，可变驻留集；局部策略，固定驻留集）

### 段式内存管理

- 分页系统的缺点（共享困难，一个页同时包含代码和数据，按页共享不现实；只能在一个虚地址空间活动，有些程序增长困难）
- 分段系统（将程序按逻辑单元分成多个段，每个段使用自己单独的地址空间）

## I/O

### I/O 管理概述

- I/O 的特点（设备控制器：CPU 和 I/O 设备之间的接口）
- 设备的分类
- I/O 管理示意图（应用程序 $\leftrightarrow$ I/O 设备管理 $\leftrightarrow$ 设备控制器，**I/O 设备管理分层**：逻辑 I/O，设备驱动程序，中断服务程序）
- I/O 管理的目标和任务（按照用户请求控制设备执行操作；建立方便、统一的独立于设备的接口；充分利用各种技术提高 CPU 与设备、设备与设备间并行工作能力；保护设备管理的数据是安全的）

### I/O 硬件组成

- I/O 设备组成（由机械和电子两部分，机械是设备本身，电子是设备控制器）
- 设备接口——控制器作用（独立于 CPU 完成指定操作，CPU 可执行其他计算；命令完成时控制器产生一个中断，CPU 响应中断，控制转移到 OS，OS 读寄存器内容获得状态信息）
- I/O 端口地址（接口电路中每个寄存器具有的唯一地址，所有 I/O 端口地址形成 I/O 端口空间；I/O 指令中访问端口地址有两种方式，内存映射编码、I/O 独立编址）
- I/O 控制方式（可编程 I/O，CPU 一直等操作完成；中断驱动 I/O，CPU 可以做其他事情，操作完成时发中断通知 CPU；DMA，I/O-内存间直接传送）

### I/O 软件组成

- I/O 软件设计中分层的设计思想（每一层执行一个子集，依赖于底层的功能，并给高层提供服务。低层考虑硬件特性，向高层提供接口；高层不依赖硬件，向用户提供简单的接口）
- I/O 软件层次（用户级 I/O 软件，与设备无关的 OS 软件，设备驱动程序，中断处理程序，硬件）
- 设备独立性（程序可访问任意 I/O 设备，无需事先指定）

### I/O 相关技术

- 缓冲技术（数据到达和离去速度不匹配的地方均可采用缓冲技术）
- 设备管理有关的数据结构
- 设备驱动程序
- 典型的实现方案：I/O 进程

### I/O 性能问题