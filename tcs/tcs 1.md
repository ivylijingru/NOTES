## tcs 第一章习题

### 1.31

完全间隔交叉$(A,B)_{0,1}$，$(Q_A\times Q_B)\times \{0,1\}$

指定$\delta((p,q,i),a) =(\delta_A(p,a),q,1), i=0; (p,\delta_B(q,a),0), i=1$

初始状态$(q_A,q_b,0)$

终结状态$F_A*F_B*\{0,1\}$

### 1.32

$\delta((p,q),a)=\{(\delta_A(p,a),q), (p,\delta_B(q,a))\}$

### 1.33

复制一份DFA，并将连接处改成$\epsilon$移动。

### 1.34

B 和 C 含有相同个数的 1，同时跑自动机，读入 1 时B，C都走。

### 1.35

如果 B 正则，而不是任意语言，那么可以同时跑A，B。在A中猜w的位置。

$\delta_A(\delta_A(q_A,w),x) \in F_A$

$\delta_B(q_B,x)\in F_B$

$M_{A/B}=(Q_A,\Sigma, \delta_A, q_A, F_{A/B} = \{p|\exist x\in B, \delta_A(p,x)\in F_A\}$

### 1.36

语言的逆序，正则表达式反过来。

### 1.37

### 1.38

想象是一个数加上上一个数的两倍

上面的数*3减下面的数%3，**三个状态**

### 1.40

用 1.48 解：上面全1，下面全0，长度为n这样的字符串在自动机中是两两不可区分的，而这样的字符串无限多。

### 1.43

$x\in L \ \ \ \ \ L=L(N) \ NFA\ N=(Q, \Sigma, \delta, q, F)$

$x\notin L \ \ \ \ \ \overline{L}=L(N') \ NFA\ N'=(Q, \Sigma, \delta, q, Q-F)$ 本质上是取补集，正则语言对补封闭。

AFA: 存在和任意的分叉。NFA 是用存在，all-DFA 用任何。

### 1.44

$A_k=\{1^{k-2}\}$ 可区分的串集合：$\{\epsilon, 0, 1, 11, ... 1^{k-2}\}$ 有k个元素两两可区分。（也是用1.48证明）

### 1.49



### 1.51

证明语言非正则  

#### b. $\{0^m1^n, m\neq n\}$ 

为什么不能用 $0^{p}1^{2p}$？

因为要保证**任何一个划分**泵出来都能导致0和1个数相等，故可取值为$0^p1^{p+p!}$

#### c. $\{w|w不是一个回文\}$

考虑语言的补，交$0^*10^*$，是一个回文$1^p01^p$

#### d. $\{wtw\}$

取 $wtw = 0^p100^p1$则在泵前面的0的时候总会导致跟后面的不一样。

### 1.52

$\{1^m\# 1^n\}$

### 1.53

01，10个数相等的串 DFA：包含五个状态，分别表示 $\epsilon $, 以0结尾一样多，以1结尾一样多，以0结尾不一样，以1结尾不一样

### 1.54

### 1.55

识别从右端起第k个位置是a的串组成的语言，$\forall k$, 没有状态数小于 $2^k$ 的 DFA 识别之

反证法，如果有状态数为$2^k-1$的DFA，则必然存在两个字符串落入同一个状态，不妨设走到最后一个字符时同时接受。找到第一个不一样的字符，设之前已经有$i$个字符，则在最后补上$0^i$。那么从这个不一样的开始（这是倒数第k个）同时接受，与要求矛盾。

### 1.57

#### a. 拆分成不相交的正则子集

找到一个循环，考虑偶数圈和奇数圈（必须对DFA找，NFA不行）

#### b. 

应用a

### 1.58

#### a. A 含有长度最大为k的串

b. ？

c. 考虑把NFA转化成DFA的算法，最大状态个数为 $2^k$, 考虑最短路径。

### 1.59

$2^n \le |Q| \le |Q_1|\times |Q_2|\times ... \times |Q_k|$

### 1.60

#### a. 正则语言在同态$f:\Sigma \rightarrow \Gamma ^* $下封闭

用NFA猜同态后的pattern

#### b. 非正则在同态下不封闭

考虑 $0^n1^n$ 并把0变成1，则成为正则语言。

### 1.61

#### a. 旋转闭包$RC(A)=\{yx|xy\in A\}$ 有 $RC(A)=RC(RC(A))$

$RC(A)$ 包含自身和旋转后的。再转回来同理。

#### b. 正则语言在旋转闭包下封闭

中间的某个状态作为起始状态，其前一个状态作为终结。把原先的终结状态和起始状态连接起来。

### 1.62

$10^p+10^p=10^{p+1}$

### 1.63 

$B_k(A)=\{w|w是A中某数的k进制数\}$，找到A使得$B_2(A)$正则而$B_3(A)$不是。

考虑二进制表示中所有2的幂次。应用泵引理：
$$
xz = 2^a\ (1)\\
xyz = 2^b\ (2)\\
xyyz = 2^c\ (3)\\
\frac{(3)-(2)}{(2)-(1)} = \frac{2^c-2^b}{2^b-2^a} =  \frac{2^{c-a}-2^{b-a}}{2^{b-a}-1}
= \frac{3^{|yz|}(xy-x)}{3^{|z|}(xy-x)}=3^{|y|}
$$
可知矛盾（写的不严谨）

### 1.64

正则语言前1/2构成的语言是正则语言

记语言A的反为$A'$. 构造有穷自动机：$(Q =  Q_A\times Q_A, \Sigma, \delta, q = q_A \times q_{A'}, F)$

其中 $\delta((p,q),a) = \{(\delta_A(p,a), \delta_{A'}(q,b))|b\in \Sigma\}$, $F = \{(x, x) | x \in Q_A\}$

想法：正着跑和反着跑，猜反着跑的时候的字符（构成NFA），两者汇合处作为终结状态。

同样道理，前1/3构成的串也是正则的（正着走一步，倒着走两步）

### 1.65

一个正则语言的前三分之一和后三分之一构成的语言是否为正则语言

反例：$0^*21^*的前1/3和后1/3 \cap 0^*1^*$ 如此操作后得到的是 $0^n1^n$, 不是正则语言

### 1.66

因为dfa最终能够达到同步，则任意两个状态也能。每次把两个状态 synchronize 成1个（局部同步）把两个状态变成同一个状态需要 $C_n^2$ 步，这是因为考虑经过一个字符之后得到的状态对一共有 $C_n^2$  种可能性，由抽屉原理必然会经过每一种可能性（如果只经过n-1个状态，那么必然会重复到达同一个状态对，此时消除循环即可）。这样每次合并两个状态，最终的复杂度为$n^3$

### 1.67

从 A 的某状态开始跑 B，如果 B 接受且 A 最后也接受则接受该 w。$A\ not\ avoid\ B$

### 1.68

#### a. $\{0^ku0^k|k\ge1\ and \ u \in \Sigma^*\}$ is regular

第一个和最后一个为0

#### b. $\{0^k1u0^k|k\ge1\ and \ u \in \Sigma^*\}$ is not regular

考虑 $0^k10^k$

### 1.69

U 是两个语言的并：

#### a.如果 U 不为空，则包含小于 $max(k_1,k_2)$ 字符串

#### b. 如果 U 不为全集，则不包含某些小于 $k_1k_2$字符串

如果包含所有长度小于$k_1k_2$字符串，由于语言的并 DFA 有$k_1k_2$个状态，那么走任意小于$k_1k_2$的步数进入的状态都被 DFA 接收。则一个所有状态都是接收状态的DFA接受$\Sigma^*$。

### 1.70 

$C =\{x \# x^R \#  x\}$

$\overline{C} = \{两个\#分开的字符串非回文，前后两个x不相等\}$

三种模型并在一起考虑，前两个、后两个非回文，以及前x后x不相等。（其他的字符串如何包含进去？）

### 1.71

#### a

$B = \{1^ky|y含有至少k个1\}=1(\Sigma^*-0^*)$

#### b

$C =  \{1^ky|y含有至多k个1\}$ 考虑两两可区分的集合 $\{1^m01|m\in \Z^+\}$ 则该集合两两可区分。对任意的x,y补一个z使得其中一个1的个数多于k1而另一个少于k2

### 1.72

$CUT(A)=\{yxz|xyz\in A\}$ 

#### a. $CUT(B) \ne CUT(CUT(B))$

$CUT(xy_1y_2) = y_1y_2x$

$CUT(y_1y_2x) = y_2y_1x$

#### b. 正则语言在CUT操作下封闭

$M = (Q,\Sigma,\delta,q_0, F), L(M)=B$

$N = (\{0,1,2\}\times Q^3\cup q_0',\Sigma,\delta,q_0', \{(2,q,p)|p\in Q\}\times F )$ （用标志位记录走到哪个阶段了）

$\delta'(q_0',\epsilon) = \{(0,p,q_0,p)|p\in Q\}$ （枚举 y 开始的状态）

$\delta'((0,p,q,r), a)= \{(0,p,q,\delta(r,a))\}$ （走y）

$\delta'((0,p,q,r), \epsilon)= \{(1,p,q,r)\}$ （移动到走 x 的状态）

$\delta'((1,p,q,r), a)= \{(0,p,\delta(q,a),r)\}$ （走x）

$\delta'((1,p,q,r), \epsilon)= \{(2,p,q,r)\}$ （移动到走 z 的状态）

$\delta'((2,p,q,r), a)= \{(2,p,q,\delta(r,a))\}$  （走z）

### 1.73

#### a. 状态数少于$2^k$DFA不能识别$WW_k$

如果状态数少于 $2^k$,则 $w_1, w_2$ 同时进入一个状态，那么 $w_1w_2, w_1w_1$ 将同时被接受（或者使用两两可区分）

 #### b. 状态更少的，能识别 $\overline {WW_k}$ 的 NFA

$w_1 \neq w_{k+1}$ 的 NFA 需要 $O(k)$ ，则有k个位置需要判断（k个分支），复杂度为 $O(k^2)$